{"remainingRequest":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/node_modules/vue-loader-v16/dist/index.js??ref--1-1!/home/mayank/gemwork_3/gem-farm/app/gem-farm/src/components/gem-bank/Vault.vue?vue&type=style&index=0&id=0ef0214d&scoped=true&lang=css","dependencies":[{"path":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/src/components/gem-bank/Vault.vue","mtime":1649527631511},{"path":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/node_modules/css-loader/dist/cjs.js","mtime":1647186846000},{"path":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/node_modules/vue-loader-v16/dist/stylePostLoader.js","mtime":1647186847000},{"path":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/node_modules/postcss-loader/src/index.js","mtime":1647186847000},{"path":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/node_modules/cache-loader/dist/cjs.js","mtime":1647186788000},{"path":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/node_modules/vue-loader-v16/dist/index.js","mtime":1647186847000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci5sb2NrZWQgewogIEBhcHBseSB0ZXh0LWNlbnRlciBiZy1ibGFjayB0ZXh0LXdoaXRlOwogIHdpZHRoOiAxMDAlOwogIGhlaWdodDogMTAwJTsKICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgdG9wOiAwOwogIGxlZnQ6IDA7CiAgb3BhY2l0eTogMC43OwogIHotaW5kZXg6IDEwOwp9Cg=="},{"version":3,"sources":["/home/mayank/gemwork_3/gem-farm/app/gem-farm/src/components/gem-bank/Vault.vue"],"names":[],"mappings":";AAiTA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;EACN,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACtC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAClB,CAAC,CAAC,CAAC,EAAE,CAAC;EACN,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;EACP,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;AACb","file":"/home/mayank/gemwork_3/gem-farm/app/gem-farm/src/components/gem-bank/Vault.vue","sourceRoot":"","sourcesContent":["<template>\n  <!--control buttons-->\n  <div class=\"mb-10 flex justify-center\">\n    <button\n      v-if=\"\n        (toWalletNFTs && toWalletNFTs.length) ||\n        (toVaultNFTs && toVaultNFTs.length)\n      \"\n      class=\"nes-btn is-primary mr-5\"\n      @click=\"moveNFTsOnChain\"\n    >\n      Move Gems!\n    </button>\n    <slot />\n  </div>\n\n  <!--wallet + vault view-->\n  <div class=\"flex items-stretch\">\n    <!--left-->\n    <NFTGrid\n      title=\"Your wallet\"\n      class=\"flex-1\"\n      :nfts=\"desiredWalletNFTs\"\n      @selected=\"handleWalletSelected\"\n    />\n\n    <!--mid-->\n    <div class=\"m-2 flex flex-col\">\n      <ArrowButton\n        :disabled=\"vaultLocked\"\n        class=\"my-2\"\n        @click=\"moveNFTsFE(false)\"\n      />\n      <ArrowButton\n        :disabled=\"vaultLocked\"\n        class=\"my-2\"\n        :left=\"true\"\n        @click=\"moveNFTsFE(true)\"\n      />\n    </div>\n\n    <!--right-->\n    <NFTGrid\n      v-if=\"bank && vault\"\n      title=\"Your vault\"\n      class=\"flex-1\"\n      :nfts=\"desiredVaultNFTs\"\n      @selected=\"handleVaultSelected\"\n    >\n      <div\n        v-if=\"vaultLocked\"\n        class=\"locked flex-col justify-center items-center align-center\"\n      >\n        <p class=\"mt-10\">This vault is locked!</p>\n      </div>\n    </NFTGrid>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, onMounted, ref, watch } from 'vue';\nimport NFTGrid from '@/components/gem-bank/NFTGrid.vue';\nimport ArrowButton from '@/components/ArrowButton.vue';\nimport useWallet from '@/composables/wallet';\nimport useCluster from '@/composables/cluster';\nimport {\n  getNFTMetadataForMany,\n  getNFTsByOwner,\n  INFT,\n} from '@/common/web3/NFTget';\nimport { initGemBank } from '@/common/gem-bank';\nimport { PublicKey } from '@solana/web3.js';\nimport { getListDiffBasedOnMints, removeManyFromList } from '@/common/util';\nimport { BN } from '@project-serum/anchor';\n\nexport default defineComponent({\n  components: { ArrowButton, NFTGrid },\n  props: {\n    vault: String,\n  },\n  emits: ['selected-wallet-nft'],\n  setup(props, ctx) {\n    const { wallet, getWallet } = useWallet();\n    const { cluster, getConnection } = useCluster();\n\n    // --------------------------------------- state\n\n    //current walet/vault state\n    const currentWalletNFTs = ref<INFT[]>([]);\n    const currentVaultNFTs = ref<INFT[]>([]);\n    //selected but not yet moved over in FE\n    const selectedWalletNFTs = ref<INFT[]>([]);\n    const selectedVaultNFTs = ref<INFT[]>([]);\n    //moved over in FE but not yet onchain\n    const desiredWalletNFTs = ref<INFT[]>([]);\n    const desiredVaultNFTs = ref<INFT[]>([]);\n    //moved over onchain\n    const toWalletNFTs = ref<INFT[]>([]);\n    const toVaultNFTs = ref<INFT[]>([]);\n\n    // --------------------------------------- populate initial nfts\n\n    const populateWalletNFTs = async () => {\n      // zero out to begin with\n      currentWalletNFTs.value = [];\n      selectedWalletNFTs.value = [];\n      desiredWalletNFTs.value = [];\n\n      if (getWallet()) {\n        currentWalletNFTs.value = await getNFTsByOwner(\n          getWallet()!.publicKey!,\n          getConnection()\n        );\n        desiredWalletNFTs.value = [...currentWalletNFTs.value];\n      }\n    };\n\n    const populateVaultNFTs = async () => {\n      // zero out to begin with\n      currentVaultNFTs.value = [];\n      selectedVaultNFTs.value = [];\n      desiredVaultNFTs.value = [];\n\n      const foundGDRs = await gb.fetchAllGdrPDAs(vault.value);\n      if (foundGDRs && foundGDRs.length) {\n        gdrs.value = foundGDRs;\n        console.log(`found a total of ${foundGDRs.length} gdrs`);\n\n        const mints = foundGDRs.map((gdr: any) => {\n          return { mint: gdr.account.gemMint };\n        });\n        currentVaultNFTs.value = await getNFTMetadataForMany(\n          mints,\n          getConnection()\n        );\n        desiredVaultNFTs.value = [...currentVaultNFTs.value];\n        console.log(\n          `populated a total of ${currentVaultNFTs.value.length} vault NFTs`\n        );\n      }\n    };\n\n    const updateVaultState = async () => {\n      vaultAcc.value = await gb.fetchVaultAcc(vault.value);\n      bank.value = vaultAcc.value.bank;\n      vaultLocked.value = vaultAcc.value.locked;\n    };\n\n    watch([wallet, cluster], async () => {\n      gb = await initGemBank(getConnection(), getWallet()!);\n\n      //populate wallet + vault nfts\n      await Promise.all([populateWalletNFTs(), populateVaultNFTs()]);\n    });\n\n    onMounted(async () => {\n      gb = await initGemBank(getConnection(), getWallet()!);\n\n      //prep vault + bank variables\n      vault.value = new PublicKey(props.vault!);\n      await updateVaultState();\n\n      //populate wallet + vault nfts\n      await Promise.all([populateWalletNFTs(), populateVaultNFTs()]);\n    });\n\n    // --------------------------------------- moving nfts\n\n    const handleWalletSelected = (e: any) => {\n      if (e.selected) {\n        selectedWalletNFTs.value.push(e.nft);\n      } else {\n        const index = selectedWalletNFTs.value.indexOf(e.nft);\n        selectedWalletNFTs.value.splice(index, 1);\n      }\n      ctx.emit('selected-wallet-nft', selectedWalletNFTs.value);\n    };\n\n    const handleVaultSelected = (e: any) => {\n      if (e.selected) {\n        selectedVaultNFTs.value.push(e.nft);\n      } else {\n        const index = selectedVaultNFTs.value.indexOf(e.nft);\n        selectedVaultNFTs.value.splice(index, 1);\n      }\n    };\n\n    const moveNFTsFE = (moveLeft: boolean) => {\n      if (moveLeft) {\n        //push selected vault nfts into desired wallet\n        desiredWalletNFTs.value.push(...selectedVaultNFTs.value);\n        //remove selected vault nfts from desired vault\n        removeManyFromList(selectedVaultNFTs.value, desiredVaultNFTs.value);\n        //empty selection list\n        selectedVaultNFTs.value = [];\n      } else {\n        //push selected wallet nfts into desired vault\n        desiredVaultNFTs.value.push(...selectedWalletNFTs.value);\n        //remove selected wallet nfts from desired wallet\n        removeManyFromList(selectedWalletNFTs.value, desiredWalletNFTs.value);\n        //empty selected walelt\n        selectedWalletNFTs.value = [];\n      }\n    };\n\n    //todo jam into single tx\n    const moveNFTsOnChain = async () => {\n      for (const nft of toVaultNFTs.value) {\n        console.log(nft);\n        const creator = new PublicKey(\n          //todo currently simply taking the 1st creator\n          (nft.onchainMetadata as any).data.creators[0].address\n        );\n        console.log('creator is', creator.toBase58());\n        await depositGem(nft.mint, creator, nft.pubkey!);\n      }\n      for (const nft of toWalletNFTs.value) {\n        await withdrawGem(nft.mint);\n      }\n      await Promise.all([populateWalletNFTs(), populateVaultNFTs()]);\n    };\n\n    //to vault = vault desired - vault current\n    watch(\n      desiredVaultNFTs,\n      () => {\n        toVaultNFTs.value = getListDiffBasedOnMints(\n          desiredVaultNFTs.value,\n          currentVaultNFTs.value\n        );\n        console.log('to vault nfts are', toVaultNFTs.value);\n      },\n      { deep: true }\n    );\n\n    //to wallet = wallet desired - wallet current\n    watch(\n      desiredWalletNFTs,\n      () => {\n        toWalletNFTs.value = getListDiffBasedOnMints(\n          desiredWalletNFTs.value,\n          currentWalletNFTs.value\n        );\n        console.log('to wallet nfts are', toWalletNFTs.value);\n      },\n      { deep: true }\n    );\n\n    // --------------------------------------- gem bank\n\n    let gb: any;\n    const bank = ref<PublicKey>();\n    const vault = ref<PublicKey>();\n    const vaultAcc = ref<any>();\n    const gdrs = ref<PublicKey[]>([]);\n    const vaultLocked = ref<boolean>(false);\n\n    const depositGem = async (\n      mint: PublicKey,\n      creator: PublicKey,\n      source: PublicKey\n    ) => {\n      const { txSig } = await gb.depositGemWallet(\n        bank.value,\n        vault.value,\n        new BN(1),\n        mint,\n        source,\n        creator\n      );\n      console.log('deposit done', txSig);\n    };\n\n    const withdrawGem = async (mint: PublicKey) => {\n      const { txSig } = await gb.withdrawGemWallet(\n        bank.value,\n        vault.value,\n        new BN(1),\n        mint\n      );\n      console.log('withdrawal done', txSig);\n    };\n\n    // --------------------------------------- return\n\n    return {\n      wallet,\n      desiredWalletNFTs,\n      desiredVaultNFTs,\n      toVaultNFTs,\n      toWalletNFTs,\n      handleWalletSelected,\n      handleVaultSelected,\n      moveNFTsFE,\n      moveNFTsOnChain,\n      bank,\n      // eslint-disable-next-line vue/no-dupe-keys\n      vault,\n      vaultLocked,\n    };\n  },\n});\n</script>\n\n<style scoped>\n.locked {\n  @apply text-center bg-black text-white;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  opacity: 0.7;\n  z-index: 10;\n}\n</style>\n"]}]}